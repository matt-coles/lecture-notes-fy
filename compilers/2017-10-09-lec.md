### Compilers

The steps of building an interpreter might be as follows:

  - Define semantics of each language term, for example an if statement or a while loop.
  - Identification of auxiliary semantic structures, these are the structures for keeping track of what's going on. One of these is usually called the 'environment', a mapping between variable names and variable values, in addition we must keep track of closures for the --C language, but this will not be present in all languages. Subpoint: a closure is just a function pointer with an attached environment. A further structure is a run-time value representation, such as type information etc. The fourth kind of structure is a representation of control flow, initially we can use the control structures of the language we are writing the interpreter in - at some point we may need to do things that are more exotic than are present in the host language.
  - Define a procedure to traverse the AST. `interpret = term * environment -> value`

Initially the environment is essentially is something that maps a name to value, or potentially a location if we need to provide updates. Considering the names `f(x+2)` this contains both the values `x` and the function or closure `f`. Note that a function is just a closure with a null environment. One potential solution is substitution, where we would reconstruct the by substituting in the values of `f` and `x`, this is similar to carrying out beta-reduction. This is expensive in both space and time, this is why we use the environment model in most conventional languages. In the environment model it is required to map a name to a location. This also means that we must consider both the lifetime of our mappings and scope (global/lexical/local/dynamic etc).

A simple interpreter solution would consist of:

  - Sequence of frames, this could be a list or a stack for example
  - Contain a name/value mappings

A compiler solution would need to index into those frames, with a compile-time map. This means that there will be a map saying where a variable might reside relevant to the stack pointer. Compilation can be considered as a process that discards as much unnecessary information to run faster but still correctly.

More formally a closure can be defined as `cl = environment x variable* x term`. Where variable* is a pointer to the argument list and term is a pointer to the body. This is a representation of a procedure or function. This kind of structure is only really necessary in a non-global scope because we need to know which environment to find the values of the free variables within the function.

# Environments

 - *R(x)* the value of *x*
 - *L(x)* the address of *x*
 - This is Strachey's names, locations and values model.

This means that names map to locations and then finally those locations refer to a value. Interpreting a name in the symbol table means finding it's associated *R* value in the environment. Assignment is a similar process but it means finding the right place int he list and then updating the next element.

# Scoping

Haskell and OCaml are examples of languages with lexical scope. This results in a broad shallow tree for environments and whilst the access cost is O(n) but n is typicall small compared to dynamic scope variable access. This is in contrast to dynamic scope, where you extend the scope of the caller rather than the callee. This results in a narrow deep tree however n is usually much larger.

# Calling conventions

  - Call by value: This is called eager evaluation or applicative order evaluation. Example: if you call f(a+b), definition f(x), x gets value of a+b.
  - Call by reference: If you call f(y), definition f(x), x gets the address of location y.
  - Call by value result: This is similar to call by value, but locations of actuals updated before return. In effect is like reference but because updates within the procedure are local is more efficient than by reference.
  - Call by name: If you call f(a+b), definition f(x), x gets a procedure of no arguments such that every time x is used in the body, the procedure gets called. If a is global, it could change between calls, this is called Jensen's device.
  - Call by need: This is similar to call-by-name, however the procedure of no arguments will be called only one time and then the value is saved and is returned for each subsequent reference to x. Or called laxy evaluation or normal-order evaluation.

** Recommended reading for this lecture is Chapter 4 of SICP **
